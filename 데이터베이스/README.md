# 데이터베이스

## 키워드
**DBMS**
- Database Management System의 약자 
- 데이터베이스를 관리하고 운영하는 소프트웨어 시스템. MySQL, Oracle, PostgreSQL 등이 있다.
- **관계형 데이터베이스 (Relational Database)** : 테이블 형태로 데이터를 저장하고, 테이블 간의 관계를 통해 데이터를 관리하는 데이터베이스


**Key**
- 테이블에서 행을 유일하게 식별하는 속성으로, PK / FK
- **Candidate Key (후보키)** : 
    - 테이블에서 튜플을 유일하게 식별할 수 있는 속성(부분 집합). 최소성(불필요한 속성 없음)과 유일성 만족. 후보키들 중 하나를 Primary Key로 선택.
- **Primary Key (기본키)**: 
    -  후보키 중 선택된 주 키. NULL 불가, 중복 불가. 설계 시 자동 증가(AutoIncrement), 복합키 고려.
- **Alternate Key (대체키)**: 
    - 후보키들 중 Primary로 선택되지 않은 나머지 키(검색/유효성검사에 사용)
- **Super Key (슈퍼키)** : 
    - 하나 이상의 속성들의 집합으로 이루어진 키. (유일성 O, 최소성 X)
- **Foreign Key (외래키)**
    - 다른 릴레이션의 Primary Key를 참조하는 속성. 참조 무결성 유지(ON DELETE/ON UPDATE 규칙)

**무결성**
- 데이터의 정확성, 일관성, 유효성이 유지되는 것
- **개체 무결성**: 
    - 모든 테이블의 기본 키는 NULL 값을 가질 수 없으며, 각 튜플(행)을 기본 키로 고유하게 식별 할 수 있어야 한다.
- **참조 무결성**:
    - 외래 키는 참조하는 테이블의 기본 키 값만 가질 수 있으며, 외래 키 값은 NULL이거나 참조 테이블에 존재하는 값이어야 한다. 참조되는 행이 삭제되면 외래 키로 참조하는 행도 삭제되어야 한다.
- **도메인 무결성** : 
    - 각 속성 값이 정해진 도메인 내의 값만 가져야 한다. 데이터 타입, 길이, 형식, 범위를 제한한다.


**Join**
- 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법
- INNER JOIN : 교집합
- INNER(교집합), LEFT OUTER(왼쪽 기준 중복), RIGHT OUTER(오른쪽 기준 중복), FULL OUTER(합집합), CROSS(*), SELF JOIN 등. 다중 테이블 조회 시 성능(인덱스, 실행계획) 주의.
- CROSS JOIN: 두 테이블의 모든 행을 서로 곱해(조합해) 가능한 모든 경우의 수를 반환하는 조인. 대량 데이터 주의.
- SELF JOIN : 하나의 테이블을 자기 자신과 조인해, 같은 테이블 내 행들을 서로 비교하거나 관계를 찾는 조인

**뷰 (View)**
- 하나 이상의 테이블에서 원하는 데이터를 선택하여 만든 가상 테이블. 삽입/수정/삭제에 제약이 있으며 인덱스를 가질 수 없음.

**SQL Injection**
- 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법
- **공격방법** :
    - **인증 우회** 
    - **데이터 노출** 
- **방어 방법** : 
    - input 값을 받을 때, 특수문자 여부 검사하기
    - SQL 서버 오류 발생 시, 해당하는 에러 메시지 감추기
    - preparestatement 사용하기

**SQL vs NoSQL**
- **SQL**: 정해진 스키마, 테이블 기반, 관계 존재, 수직 확장. ACID 강점.
- **NoSQL** : 스키마 없음, 문서형 저장, 관계 없음, 수평 확장 가능. 선택 기준: 데이터 구조, 변경 빈도, 확장 필요성
- SQL은 구조적·정확한 관계형 데이터에 적합하고, NoSQL은 유연하고 대규모 분산·읽기 중심 데이터에 적합.

**Anomaly (이상 현상)**
- **삽입 이상 (Insertion Anomaly)** : 불필요한 데이터를 추가해야지, 삽입할 수 있는 상황
- **갱신 이상 (Update Anomaly)** : 일부만 변경하여, 데이터가 불일치 하는 모순의 문제
- **삭제 이상 (Deletion Anomaly)** : 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제
- 잘못된 테이블 설계로 생기는 이상 현상. 정규화 적용으로 해결.

**index**
- 검색 속도 향상 기술. 테이블 컬럼을 색인화.
- 사용 시 검색 속도 향상, DML 작업(INSERT/UPDATE/DELETE) 시 성능 저하
- B-Tree, Hash, Bitmap, Unique, Composite(복합), Covering 인덱스, Clustered vs Non-clustered 등 존재. 

**정규화(Normalization)** 
- 데이터 중복을 최소화하고, 이상현상을 제거하기 위해 테이블을 분해하는 과정
- 1NF: 테이블의 모든 컬럼이 원자값만 가지도록 함.
- 2NF: 부분 함수 종속 제거 → 기본키의 일부에만 종속된 컬럼을 분리.
- 3NF: 이행적 함수 종속 제거 → 기본키가 아닌 컬럼 간 종속성을 제거.
- **Denormalization (역정규화)** : 읽기 성능 향상을 위해 중복을 일부 허용 — 트레이드오프 분석 필요.

**트랜잭션 (Transaction)**
- 데이터베이스에서 실행 되는 하나의 논리적 작업 단위.
- Isolation Level (격리 수준) :Read Uncommitted, Read Committed, Repeatable Read, Serializable. 각 수준에서 발생 가능한 문제: 
    - Dirty Read : 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상

    - Non-Repeatable Read : 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

    - Phantom Read : 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상

- Concurrency Anomalies : 여러 트랜잭션이나 프로세스가 동시에 공유 데이터에 접근할 때 발생하는 이상 현상
    -  읽기 불안정성(Dirty Read): 아직 커밋되지 않은 트랜잭션의 데이터를 다른 트랜잭션이 읽는 경우.
    - 반복 불가능한 읽기(Non-repeatable Read): 한 트랜잭션 내에서 동일한 데이터를 두 번 읽을 때 값이 달라지는 경우.
    - 팬텀 읽기(Phantom Read): 특정 조건에 맞는 데이터가 새로 삽입되거나 삭제되어 같은 쿼리를 다시 실행했을 때 결과 집합이 달라지는 경우. 

**ACID** 
- 트랜잭션이 안전하게 수행되기 위한 4가지 속성
- **Atomicity (원자성)** : 
    - 한 단위(트랜잭션)의 모든 연산이 완전히 수행되거나 전혀 수행되지 않아야 함.
- **Consistency (일관성)** : 
    - 트랜잭션 실행 전후로 데이터베이스가 일관된 상태를 유지해야 한다. 무결성 제약 조건을 만족해야 함.
- **Isolation (격리성)** : 
    - 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않아야 한다. 각 트랜잭션은 독립적으로 실행되는 것처럼 보여야 함.
- **Durability (지속성)**
    - 트랜잭션이 성공적으로 완료되면 그 결과가 영구적으로 반영되어야 한다. 로그 파일과 백업으로 보장함.

**Locking / MVCC** 
- 데이터베이스에서 여러 트랜잭션이 동시에 데이터를 사용할 때 발생하는 충돌을 막고 데이터의 일관성을 유지하는 동시성 제어 방식
- Locking : 데이터를 읽거나 쓸 때, 해당 데이터에 잠금을 걸어 다른 트랜잭션이 접근하지 못하게 막음. 기다리는 대기 시간으로 인해 속도 저하.
- MVCC (Multi-Version Concurrency Control) :  데이터를 수정할 때마다 새로운 버전의 데이터를 생성하고, 각 트랜잭션은 자신이 시작했을 때의 데이터 버전을 읽음. 데이터 저장 공간 필요. 

**캐시 (Cache)** 
- 자주 사용되는 데이터를 메모리에 저장하여 빠르게 접근하는 기법으로, 데이터베이스 접근을 줄여 성능을 향상시킴.

**샤딩 (Sharding)** 
- 데이터를 여러 데이터베이스 서버에 수평 분할하여 저장하는 기법, 하나의 큰 테이블을 여러 서버에 나누어 저장. 쓰기 성능 향상. 
- **파티셔닝 (Partitioning)** : 
    - 대용량 테이블을 물리적으로 여러 개의 작은 단위로 나누어 관리하는 기법, 하나의 데이터베이스 서버 내에서 테이블을 분류
- **Replication**
    - 데이터를 복사하여 여러 서버에 분산시키는 기술. 읽기 성능 향상

**Redis** 
- 빠른 오픈 소스 인 메모리 키 값 데이터 구조 스토어. Redis는 메모리(RAM)에 저장해서 디스크 스캐닝이 필요없어 매우 빠른 장점이 존재
- 데이터 타입: String, List, Set, Sorted Set, Hash.

**저장 프로시저(Stored Procedure)** 
- SQL 쿼리 집합을 함수처럼 실행. 
- 장점: 최적화/캐시, 유지보수, 트래픽 감소, 보안 
- 단점: 호환성, 성능, 디버깅 어려움

---
## 질문답 
## Join 관련
### 1. Inner Join과 Outer Join의 차이점은 무엇인가?
- **Inner Join**: 두 테이블에서 조인 조건을 만족하는 행만 반환 (교집합)
- **Outer Join**: 조건을 만족하지 않는 행도 포함하여 반환
    - LEFT: 왼쪽 테이블의 모든 행 포함
    - RIGHT: 오른쪽 테이블의 모든 행 포함
    - FULL: 양쪽 테이블의 모든 행 포함

### 2. 각 Join은 실제로 어떤 상황에 적합하게 사용되는가?
- **INNER JOIN** : 
    - 두 테이블에 모두 존재하는, 연관된 데이터만 필요할 때
- **OUTER JOIN** : 
    - 특정 테이블의 모든 데이터를 유지하면서, 해당 데이터와 연관된 다른 테이블의 정보가 있는지 확인하거나 가져오고 싶을 때.
- **FULL OUTER JOIN** : 
    -  두 테이블의 전체적인 관계와 누락된 데이터를 동시에 파악하고 싶을 때
- **CROSS JOIN** : 
    - 일반적으로 사용 X. 모든 가능한 조합을 생성해야할 때 제한적 사용
- **SELF JOIN** : 
    - 테이블 내에서 행과 행 사이의 계층적 또는 관련된 정보를 검색할 때

## 트랜잭션 & ACID 관련
### 3. 트랜잭션이 필요한 경우 NoSQL에서는 어떻게 처리하는가?
- **MongoDB**  : 멀티 트랜잭션을 지원
    - 4.0 버전(레플리카 셋) 및 4.2 버전(샤딩 클러스터)부터 ACID 속성을 완전히 갖춘 멀티 문서 트랜잭션을 지원

- **Redise** :
    - MULTI/EXEC 명령어로 트랜잭션 실행

### 4. ACID가 무엇인가? 
**ACID** : 
-  데이터베이스 트랜잭션의 안정성을 보장하는 4가지 속성

- **Atomicity (원자성)**:
    - 트랜잭션 단위의 모든 연산이 전부 성공하거나 전부 실패해야 함
    - "All or Nothing" 원칙
    - 예: 계좌이체 시 출금과 입금이 모두 성공하거나 모두 취소

- **Consistency (일관성)**:
    - 트랜잭션 실행 전후로 데이터베이스가 일관된 상태를 유지
    - 모든 제약조건(constraints)이 지켜져야 함
    - 예: 잔액은 항상 0 이상이어야 한다는 규칙 유지

- **Isolation (격리성)** :
    - 동시에 실행되는 트랜잭션들이 서로 간섭하지 않음
    - 각 트랜잭션은 독립적으로 실행되는 것처럼 동작
    - 예: A와 B가 동시에 같은 계좌를 수정해도 결과가 올바름

- **Durability (지속성)**:
    - 커밋된 트랜잭션의 결과는 영구적으로 저장됨
    - 시스템 장애 후에도 데이터가 보존됨
    - 예: 트랜잭션 완료 후 정전이 발생해도 데이터는 유지

### 5.  Isolation level의 필요성은 무엇인가?
- **데이터의 일관성**과 **시스템 성능** 사이의 최적의 균형점을 찾기 위함.
- 낮은 수준 → 성능↑
- 높은 수준 → 일관성↑

### 6. Isolation level을 어떻게 적절하게 선택하는가?
- 데이터 정확성 요구도에 따라 선택. 정확성이 중요하면 높은 수준을 선택/ 성능이 우선이면 낮은 수준을 선택.
- 기본은 Read Committed를 사용.
- **READ UNCOMMITTED** : 대략적인 통계, 로그 조회
- **READ COMMITTED**: 일반적인 웹 애플리케이션 (기본값)
- **REPEATABLE READ**: 데이터 일관성이 중요한 경우
- **SERIALIZABLE**: 금융 거래 등 정확성이 최우선인 경우

## 정규화 & 성능 관련
### 7.  정규화를 하면 데이터베이스 성능이 항상 좋아지는가?
→ **아니다**
- **정규화의 장점** : 데이터 중복 최소화, 무결성 향상, 수정/삭제 성능 향상
- **정규화의 단점**: 조회 시 JOIN으로 인한 성능 저하
- 실무: OLTP는 정규화, OLAP는 반정규화 권장

## Redis & 저장소 관리 관련
### 8. Redis는 RAM을 사용하는데 만약 RAM 공간이 다 차있게 된다면 Redis는 실행 도중 어떤 처리를 할까?
- 설정된 Eviction Policy에 따라 데이터를 제거한다.
- Eviction Policy: 메모리 캐시가 가득 찼을 때 어떤 데이터를 제거할지 결정하는 정책
    - noeviction: 쓰기 명령 거부
    - allkeys-lru: 가장 오래 사용되지 않은 키 삭제
    - volatile-ttl: TTL이 짧은 키부터 삭제
    - allkeys-lfu: 가장 적게 사용된 키 삭제

### 9. 데이터를 SSD에 저장하는 경우 SSD가 꽉 차서 허용 공간이 없다면 어떻게 처리할 수 있을까?
- 운영체제 (OS) 및 파일 시스템
    - 운영체제(Windows, Linux 등)는 새로운 파일 쓰기 요청에 대해 즉시 "디스크 공간 부족(No space left on device)" 오류를 반환하며 쓰기 작업을 중단
        - Linux/Unix: ```ENOSPC``` 에러 반환
        - Windows: "디스크 공간 부족" 오류 발생

- 데이터베이스 (DB)
    - 쓰기 트랜잭션 실패 시 새로운 INSERT, UPDATE 트랜잭션은 공간 부족 오류와 함께 자동으로 롤백

- SSD 자체 처리 (Wear Leveling)
    - SSD 자체는 공간이 꽉 차더라도 수명 관리를 위해 일부 여유 공간을 미리 확보함. 여유 공간마저 소진되면 SSD 컨트롤러는 데이터를 지우고 쓰는(Garbage Collection) 작업을 매우 느리게 수행해야 하므로 SSD의 쓰기 성능이 급격히 저하됨.

- 처리 방법:
    - 불필요 파일 삭제
    - 데이터 아카이빙
    - SSD 용량 확장
    - 데이터 압축/정리

### 10. 보통 이미지 데이터를 어떤 형식으로 SQL에 저장하는가?
- 파일 경로 저장 (권장): 이미지는 파일 시스템/클라우드에 저장, DB에는 URL만 저장
- BLOB 타입: 바이너리 데이터를 DB에 직접 저장 (DB 크기 증가, 성능 저하)
- Base64 인코딩: 텍스트로 저장 (데이터 크기 33% 증가)
- 실무: 클라우드 스토리지(S3 등) + URL 저장 방식 선호

## 데이터베이스 내부 구조 관련
### 11. 데이터베이스의 데이터들은 내부적으로 어떻게 저장되어있는가?
- **테이블 파일로 저장** : 각 테이블(또는 인덱스)은 운영체제(OS)의 디스크 파일 형태로 저장
- **페이지 단위 저장** : 
    - 4KB, 8KB, 16KB 크기로 관리
    - 데이터베이스는 데이터를 읽고 쓸 때 이 페이지 단위로 메모리(버퍼 풀)와 디스크 사이를 이동.
- **인덱스 구조**: B+Tree (검색/삽입/삭제 O(log N))
- **저장 방식**
    - 행 기반 저장: OLTP에 적합 (MySQL, PostgreSQL)
    - 열 기반 저장: OLAP에 적합 (Redshift, BigQuery)
- **버퍼 풀**: 
    - 자주 사용되는 디스크의 페이지들은 메모리(RAM) 상의 버퍼 풀이라는 공간에 복사되어 보관. 

## 캐시 전략 관련
### 12. SQL 캐시 전략의 종류는 무엇인가?
- **Cache-Aside**: 캐시 확인 → 없으면 DB 조회 후 캐시 저장
- **Write-Through**: 쓰기 시 캐시와 DB에 동시 저장
- **Write-Behind**: 캐시에 먼저 쓰고 비동기로 DB 반영
- **Read-Through**: 캐시가 DB 조회를 대신 처리
- **TTL 기반**: 일정 시간 후 캐시 자동 만료

### 13. MySQL 8.0에서 쿼리 캐시가 제거된 이유는 무엇인가?
- **확장성 문제**: 전역 뮤텍스로 인한 동시성 병목
- **캐시 무효화 오버헤드**: 테이블 변경 시 관련 캐시 전체 무효화
- **낮은 히트율**: 동적 쿼리 환경에서 재사용률 낮음
- **대안 존재** : Redis/Memcached, InnoDB Buffer Pool이 더 효율적

## 데이터 분산 관련
### 14. 샤딩과 파티셔닝의 차이점은 무엇인가?
- **파티셔닝**: 단일 서버 내에서 테이블을 작은 단위로 분할
    - 목적: 쿼리 성능 향상, 관리 용이성
    - 예: 날짜별, 지역별 파티션
- **샤딩**: 여러 데이터베이스 서버에 데이터 분산 저장
    - 목적: 수평적 확장(Scale-out), 대용량 데이터 처리
    - 예: user_id 기준으로 여러 서버에 분산

- **차이점**:
    | 구분 | 샤딩 (Sharding) | 파티셔닝 (Partitioning) |
    |---- |---- |---- |
    |  분산 주체 |  전체 데이터베이스 (DB 인스턴스) | 단일 테이블 (DB 서버 내) |
    | 경계  |  물리적 서버 |  논리적 테이블 구조 |
    |  효과 | 	용량 및 트래픽 한계 돌파  |  검색 범위 축소, 관리 용이성 증대 |