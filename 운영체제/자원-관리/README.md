# 운영체제 - 자원 관리

## 키워드

**CPU (Central Processing Unit)**

- 연산과 제어 담당
- 프로세스/스레드 실행 관리

**인터럽트 (Interrupt)**

- 프로그램 실행 중 예외 상황 발생 시 CPU에 알리고 처리하는 메커니즘
  - **외부 인터럽트**: 하드웨어 신호 (I/O 완료, 전원 이상 등)
  - **내부 인터럽트**: 예외 상황 (0으로 나누기 등)
  - **소프트웨어 인터럽트**: 시스템 콜 등 명령어에 의한 발생
  - **폴링**: CPU가 상태를 반복 확인 (비효율적)
  - **ISR**: 인터럽트 처리 루틴

**PCB & Context Switching**

- **PCB(Process Control Block)**: 프로세스 정보 저장 (PID, 상태, 레지스터 등)
- **Context Switching**: 실행 중인 프로세스 상태 저장 → 다른 프로세스 상태 복원
  - **Overhead**: 빈번하면 성능 저하
  - 발생 시점: 인터럽트, I/O 대기, 타임 슬라이스 종료 등

**프로세스 간 통신 (IPC)**

- 독립 프로세스 간 데이터 전달 방법
  - **파이프**: 익명(부모-자식) / 네임드(파일 기반, 관계 없음)
  - **메시지 큐**: 메시지 단위 통신
  - **공유 메모리**: 메모리 공간 직접 공유, 속도 빠름
  - **메모리 맵**: 파일을 메모리에 매핑해 공유
  - **소켓**: 네트워크 기반 통신 (로컬/원격)

**CPU 스케줄링**

- CPU 사용을 최적화하기 위한 실행 순서 결정
  - **선점형**: 실행 중에도 CPU 회수 가능 (RR, SRTF 등)
  - **비선점형**: 프로세스가 종료되거나 대기 상태로 전환될 때까지 유지 (FCFS, SJF)
  - **RR (Round Robin)**: 고정 시간 단위로 순환 실행
  - **우선순위 스케줄링**: 우선순위 높은 프로세스 먼저 실행

**데드락 & 경쟁 상태**

- **Deadlock**: 자원 점유 후 서로 기다려서 무한 대기 상태
  - 발생 조건: 상호 배제, 점유 대기, 비선점, 순환 대기
  - 해결: 예방, 회피(Banker 알고리즘), 탐지 및 회복
- **Race Condition**: 다수 프로세스가 동시에 자원 접근하여 결과가 달라지는 상태

**동기화 (Semaphore & Mutex)**

- **임계 구역**: 공유 자원 접근 영역, 동시에 접근 시 충돌 위험
- **세마포어**: 자원 개수만큼 접근 허용 (P: 진입 / V: 종료)
- **뮤텍스**: 하나의 스레드만 접근 가능 (lock/unlock 방식)

**메모리 관리 (페이징 & 세그먼테이션)**

- **페이징(Paging)**: 고정 크기 페이지로 나눠 메모리 할당 (내부 단편화 발생)
- **세그먼테이션(Segmentation)**: 논리 단위(코드/데이터 등)로 나눔 (외부 단편화 발생)
- **가상 메모리**: 필요한 페이지만 메모리에 적재 (스와핑, 페이지 폴트 등 발생)
- **MMU**: 논리 주소 → 물리 주소 변환, 메모리 접근 보호

**페이지 교체 알고리즘**

- 메모리가 가득 찼을 때, 어떤 페이지를 교체할지 결정
  - **FIFO**: 가장 먼저 들어온 페이지 제거
  - **OPT**: 가장 나중에 사용될 페이지 제거 (이론상 최적)
  - **LRU**: 가장 오랫동안 사용되지 않은 페이지 제거
  - **Global vs Local 교체**: 전체 or 프로세스 내에서 교체 범위 결정

**캐시 & 메인 메모리**

- **메인 메모리**: CPU가 직접 접근하는 실행 공간
- **캐시 메모리**: 자주 사용하는 데이터 저장, 속도 향상 (시간·공간 지역성 활용)
- **캐시 라인**: 캐시에 저장되는 데이터 묶음 단위

**파일 시스템**

- 저장 장치의 파일 및 디렉터리를 관리하는 시스템
  - **접근 방식**: 순차 접근, 직접 접근, 색인 접근
  - **디렉터리 구조**: 1단계, 2단계, 트리형, 그래프형
  - **역할**: 파일 관리, 접근 제어, 무결성 유지

## 질문과 답변

## Deadlock & Starvation

### 1. Deadlock 발생 조건 중 가장 제거하기 쉬운 것은?

### 2. 점유 대기 상태에서 프로세스는 Running인가, Waiting인가?

### 3. Deadlock 처리 방법 중 탐지 후 회복 시 자원 선점에서 데이터 일관성 문제는 어떻게 해결하는가?

### 4. 기아 상태(Starvation)란 무엇이며, 교착상태(Deadlock)과 어떻게 다른가? 예방 방법은?

## 프로세스 & 스케줄링

### 1. 장기 스케줄러, 중기 스케줄러, 단기 스케줄러의 역할은? 이름이 이렇게 분류된 이유는?

### 2. 기아 프로세스와 좀비 프로세스 발생 이유 및 해결 방법은?

### 3. 콘보이 현상(convoy effect)이란 무엇이며, CPU 스케줄러 알고리즘에서 발생하는가?

## 동시성 & 동기화

### 1. Race Condition은 언제 발생하며, 어떻게 예방할 수 있는가?

### 2. ISR 중 또 다른 인터럽트 발생 시 처리 방법은?

## 메모리 & 주소 변환

### 1. 물리 주소를 논리 주소로 변환하여 관리하는 장점은?
